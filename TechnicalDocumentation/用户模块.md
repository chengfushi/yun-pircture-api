# 一、需求分析
对于用户模块，通常要具有下列功能：
- 用户注册
- 用户登录
- 获取当前登录用户
- 用户注销
- 用户权限控制
- 【管理员】管理用户

具体分析每个需求:
1. 用户注册：用户可以通过输入账号、密码、确认密码进行注册
2. 用户登录：用户可以通过输入账号和密码登录
3. 获取当前登录用户：得到当前已经登录的用户信息（不用重复登录）
4. 用户注销：用户可以退出登录
5. 用户权限控制：用户又分为普通用户和管理员，管理员拥有整个系统的最高权限，比如可以管理其他用户
6. 用户管理：仅管理员可用，可以对整个系统中的用户进行管理，比如搜索用户、删除用户

# 二、具体实现
## 用户注册
1. 参数接受
2. 参数校验
3. 密码加密、撒盐
4. 将用户插入到数据库中

## 用户登录
1. 参数接受
2. 参数校验
3. 密码加盐加密
4. 将账号密码和数据库进行比对，如果存在代表登录成功
5. 将用户存储到session中，将session放到redis中

## 获取当前用户
1. 从session中读取当前用户
2. 对用户信息进行脱敏
## 用户注销
直接在HttpServletRequest中将登录态的session移除即可

## 用户权限控制
权限校验其实是一个比较通用的业务需求，一般会通过**SpringAOP切面+自定义权限校验注解**实现统一的接口拦截和权限校验；如果有特殊的权限校验逻辑，再单独在接口中编码。

1. 权限校验注解
首先编写权限校验注解，放到annotation包下：
```java
@Target({ElementType.METHOD})  
@Retention(RetentionPolicy.RUNTIME)  
public @interface AuthCheck {  
    /*  
    * 必须有某个角色  
    * */    String mustRole() default "";  
  
}
```

2. 权限校验切面
编写权限校验AOP，采用环绕通知，在**打上该注解的方法**执行前后进行一些额外的操作，比如校验权限。代码如下，放到aop包下：
```java
@Aspect  
@Component  
public class AuthInterceptor {  
    @Resource  
    private UserService userService;  
  
    /*  
    * 权限拦截  
    * @param joinPoint    * @param authCheck    * @return    * */  
	@Around("@annotation(authCheck)")
    public Object doInterceptor(ProceedingJoinPoint joinPoint, AuthCheck authCheck) throws Throwable {  
        //获取必须的权限  
        String mustRole = authCheck.mustRole();  
  
        //获取当前登录用户  
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();  
        HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();  
  
        //当前用户  
        User loginUser = userService.getLoginUser(request);  
  
        //获取必须权限的枚举值  
        UserRoleEnum mustRoleEnum = UserRoleEnum.getEnumByValue(mustRole);  
  
        //不需要权限，放行  
        if (mustRoleEnum == null){  
            return joinPoint.proceed();  
        }  
  
        //获取当前用户具有的权限  
        UserRoleEnum userRoleEnum = UserRoleEnum.getEnumByValue(loginUser.getUserRole());  
  
        //没有权限，拒绝  
        if (userRoleEnum == null){  
            throw new BusinessException(ErrorCode.NO_AUTH_ERROR);  
        }  
  
        //要求必须有管理员权限  
        if (UserRoleEnum.ADMIN.equals(mustRoleEnum) && !UserRoleEnum.ADMIN.equals(userRoleEnum)){  
            throw new BusinessException(ErrorCode.NO_AUTH_ERROR);  
        }  
  
        //放行  
        return joinPoint.proceed();  
    }  
  
}
```
3. 使用注解
只要给方法添加了@AuthCheck注解，就必须要登录，否则会抛出异常。可以设置mustRole为管理员，这样仅管理员才能使用该接口：
```java
@AuthCheck(mustRole = UserConstant.ADMIN_ROLE)
```

## 用户管理
用户管理，简单来说，就是crud的代码，属于最基本的业务代码。
用户管理功能具体可以拆分为：
【管理员】创建用户
【管理员】根据 id删除用户
【管理员】更新用户
【管理员】分页获取用户列表（需要脱敏)
【管理员】根据id获取用户（未脱敏）
- 根据 id获取用户（脱敏)

1. 数据模型:每个操作都需要提供一个请求类，都放在dto.user包下。
2. 服务开发，接口开发
3. 分页功能修复
	必须要配置一个分页插件。
```xml
<!-- MyBatis Plus 分页插件 -->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-jsqlparser-4.9</artifactId>
</dependency>
```
 光引入这一条，大概率是无法成功下载依赖的，还要在pom.xml的依赖管理配置中补充mybatis-plus-bom：
```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>${spring-boot.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-bom</artifactId>
            <version>3.5.9</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

依赖下载成功后，在config包下新建MyBatisPlus拦截器配置，添加分页插件：
```java
@Configuration
@MapperScan("com.yupi.yupicturebackend.mapper")
public class MyBatisPlusConfig {

    /**
     * 拦截器配置
     *
     * @return {@link MybatisPlusInterceptor}
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        // 分页插件
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}

```

4. 数据精度控制
```java
/**
 * Spring MVC Json 配置
 */
@JsonComponent
public class JsonConfig {

    /**
     * 添加 Long 转 json 精度丢失的配置
     */
    @Bean
    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {
        ObjectMapper objectMapper = builder.createXmlMapper(false).build();
        SimpleModule module = new SimpleModule();
        module.addSerializer(Long.class, ToStringSerializer.instance);
        module.addSerializer(Long.TYPE, ToStringSerializer.instance);
        objectMapper.registerModule(module);
        return objectMapper;
    }
}

```
